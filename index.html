<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IIDX TRAINING LAB</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
/* ===== Reset & Base ===== */
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;overflow:hidden}
body{font-family:'Rajdhani',sans-serif;background:#0a0a12;color:#e0e0e8;display:flex;flex-direction:column}

/* ===== Header ===== */
#header{display:flex;align-items:center;justify-content:space-between;padding:8px 20px;background:linear-gradient(90deg,#0d0d1a,#1a1a2e);border-bottom:1px solid #2a2a4a;min-height:48px;z-index:10}
#header h1{font-family:'Orbitron',sans-serif;font-size:20px;font-weight:900;letter-spacing:3px;background:linear-gradient(90deg,#00d4ff,#7b2ff7);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
#controller-status{display:flex;align-items:center;gap:8px;font-size:13px}
#controller-status .dot{width:10px;height:10px;border-radius:50%;background:#cc2222;box-shadow:0 0 6px #cc2222;transition:all .3s}
#controller-status.connected .dot{background:#22cc44;box-shadow:0 0 6px #22cc44}

/* ===== Layout ===== */
#app{display:flex;flex:1;overflow:hidden}

/* ===== Sidebar ===== */
#sidebar{width:220px;background:#0d0d1a;border-right:1px solid #2a2a4a;display:flex;flex-direction:column;padding:10px 0;overflow-y:auto;flex-shrink:0}
.mode-btn{display:flex;align-items:center;gap:10px;padding:12px 16px;border:none;background:transparent;color:#8888aa;cursor:pointer;text-align:left;transition:all .2s;border-left:3px solid transparent;font-family:'Rajdhani',sans-serif;font-size:14px}
.mode-btn:hover{background:#1a1a2e;color:#c0c0d0}
.mode-btn.active{background:#1a1a2e;color:#00d4ff;border-left-color:#00d4ff}
.mode-btn .icon{font-size:22px;width:28px;text-align:center}
.mode-btn .label{display:flex;flex-direction:column}
.mode-btn .label span:first-child{font-weight:600;font-size:14px}
.mode-btn .label span:last-child{font-size:11px;opacity:.6}

/* ===== Content ===== */
#content{flex:1;display:flex;flex-direction:column;overflow-y:auto;padding:16px 20px;gap:16px}

/* ===== Controller Visualizer ===== */
#visualizer{display:flex;align-items:center;gap:16px;padding:12px 16px;background:#111122;border-radius:8px;border:1px solid #2a2a4a}
#turntable{width:80px;height:80px;border-radius:50%;border:3px solid #444;background:radial-gradient(circle,#222 40%,#111 70%,#333 100%);position:relative;transition:transform .05s linear}
#turntable::after{content:'';position:absolute;top:50%;left:50%;width:12px;height:12px;background:#cc2222;border-radius:50%;transform:translate(-50%,-50%)}
#turntable .marker{position:absolute;top:6px;left:50%;width:2px;height:16px;background:#cc2222;transform:translateX(-50%);border-radius:1px}
#keys-viz{display:flex;gap:3px;align-items:flex-end}
.key-viz{width:36px;height:56px;border-radius:4px;border:1px solid #555;display:flex;align-items:flex-end;justify-content:center;padding-bottom:4px;font-family:'Orbitron',sans-serif;font-size:10px;color:#666;transition:all .06s;cursor:pointer}
.key-viz.white{background:linear-gradient(180deg,#3a3a4a,#2a2a3a)}
.key-viz.blue{background:linear-gradient(180deg,#1a2a5a,#0f1a3a)}
.key-viz.white.pressed{background:linear-gradient(180deg,#d0d0e0,#a0a0c0);color:#222;box-shadow:0 0 12px rgba(200,200,240,.5)}
.key-viz.blue.pressed{background:linear-gradient(180deg,#3366dd,#2244aa);color:#fff;box-shadow:0 0 12px rgba(50,100,220,.5)}
#scratch-indicator{font-family:'Rajdhani',sans-serif;font-size:12px;color:#888;margin-left:8px;min-width:40px}

/* ===== Mode Panels ===== */
.mode-panel{display:none;flex-direction:column;gap:14px}
.mode-panel.active{display:flex}
.panel-title{font-family:'Orbitron',sans-serif;font-size:18px;font-weight:700;color:#00d4ff}
.panel-controls{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
.control-group{display:flex;flex-direction:column;gap:4px}
.control-group label{font-size:12px;color:#888;font-weight:500}
.control-group select,.control-group input[type="number"]{background:#1a1a2e;border:1px solid #3a3a5a;color:#e0e0e8;padding:6px 10px;border-radius:4px;font-family:'Rajdhani',sans-serif;font-size:14px;min-width:80px}
.control-group input[type="range"]{accent-color:#00d4ff}
.btn{padding:8px 20px;border:none;border-radius:4px;font-family:'Rajdhani',sans-serif;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s}
.btn-primary{background:linear-gradient(135deg,#00d4ff,#7b2ff7);color:#fff}
.btn-primary:hover{opacity:.85;box-shadow:0 0 12px rgba(0,212,255,.3)}
.btn-danger{background:#cc2222;color:#fff}
.btn-danger:hover{opacity:.85}
.btn-secondary{background:#2a2a4a;color:#c0c0d0}
.btn-secondary:hover{background:#3a3a5a}
.stats-row{display:flex;flex-wrap:wrap;gap:12px}
.stat-box{background:#111122;border:1px solid #2a2a4a;border-radius:6px;padding:10px 16px;min-width:100px;text-align:center}
.stat-box .val{font-family:'Orbitron',sans-serif;font-size:22px;font-weight:700;color:#00d4ff}
.stat-box .lbl{font-size:11px;color:#888;margin-top:2px}

/* ===== Play Area ===== */
#play-area{position:relative;width:100%;height:500px;background:#0a0a14;border:1px solid #2a2a4a;border-radius:6px;overflow:hidden;user-select:none}
#lanes-container{position:absolute;inset:0;display:flex}
.lane{position:relative;height:100%;border-right:1px solid #1a1a2a}
.lane:last-child{border-right:none}
.lane.scratch-lane{width:12%}
.lane.key-lane{flex:1}
.lane-bg{position:absolute;inset:0;opacity:.08}
.lane.scratch-lane .lane-bg{background:#cc2222}
.lane.white-lane .lane-bg{background:#e0e0f0}
.lane.blue-lane .lane-bg{background:#2244cc}
#judgment-line{position:absolute;bottom:60px;left:0;right:0;height:3px;background:linear-gradient(90deg,#ff4444,#00d4ff,#7b2ff7);box-shadow:0 0 8px rgba(0,212,255,.4);z-index:5}
.note{position:absolute;height:12px;border-radius:2px;z-index:3;transition:none}
.note.scratch-note{left:2%;width:96%;background:linear-gradient(90deg,#cc2222,#ff4444);box-shadow:0 0 6px rgba(255,68,68,.4)}
.note.white-note{left:8%;width:84%;background:rgba(224,224,240,.85);box-shadow:0 0 4px rgba(224,224,240,.3)}
.note.blue-note{left:8%;width:84%;background:rgba(34,68,204,.85);box-shadow:0 0 4px rgba(34,68,204,.3)}
#judgment-display{position:absolute;bottom:80px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:28px;font-weight:700;z-index:10;pointer-events:none;opacity:0;transition:opacity .15s}
#combo-display{position:absolute;bottom:120px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:36px;font-weight:900;color:#ffd700;z-index:10;pointer-events:none;opacity:0}
#play-info{position:absolute;top:8px;right:12px;font-family:'Orbitron',sans-serif;font-size:12px;color:#888;z-index:10;text-align:right;line-height:1.6}
.lane-flash{position:absolute;bottom:0;left:0;right:0;height:80px;opacity:0;z-index:2;pointer-events:none;transition:opacity .06s}
.lane.scratch-lane .lane-flash{background:linear-gradient(0deg,rgba(255,68,68,.4),transparent)}
.lane.white-lane .lane-flash{background:linear-gradient(0deg,rgba(224,224,240,.3),transparent)}
.lane.blue-lane .lane-flash{background:linear-gradient(0deg,rgba(34,68,204,.3),transparent)}

/* ===== Result Overlay ===== */
#result-overlay{display:none;position:absolute;inset:0;background:rgba(0,0,0,.85);z-index:20;flex-direction:column;align-items:center;justify-content:center;gap:16px;padding:20px}
#result-overlay.active{display:flex}
#result-overlay h2{font-family:'Orbitron',sans-serif;font-size:24px;color:#00d4ff}
#result-stats{display:flex;flex-wrap:wrap;gap:10px;justify-content:center}

/* ===== Recognition Mode ===== */
#recognition-display{display:flex;gap:4px;align-items:flex-end;justify-content:center;padding:20px}
.recog-key{width:48px;height:64px;border-radius:6px;border:2px solid #444;display:flex;align-items:center;justify-content:center;font-family:'Orbitron',sans-serif;font-size:14px;color:#555}
.recog-key.active{border-color:#00d4ff;color:#00d4ff;box-shadow:0 0 12px rgba(0,212,255,.3)}
.recog-key.correct{border-color:#22cc44;color:#22cc44;box-shadow:0 0 12px rgba(34,204,68,.3)}
.recog-key.wrong{border-color:#cc2222;color:#cc2222;box-shadow:0 0 12px rgba(204,34,34,.3)}
#recog-status{font-family:'Orbitron',sans-serif;font-size:24px;text-align:center;min-height:40px;color:#ffd700}
#recog-timer-bar{width:100%;max-width:400px;height:6px;background:#222;border-radius:3px;margin:0 auto;overflow:hidden}
#recog-timer-fill{height:100%;background:linear-gradient(90deg,#00d4ff,#7b2ff7);transition:width linear}

/* ===== Tap Speed Mode ===== */
#tap-target-area{min-height:120px;background:#111122;border:2px dashed #2a2a4a;border-radius:8px;display:flex;align-items:center;justify-content:center;font-family:'Orbitron',sans-serif;font-size:16px;color:#555}
#tap-target-area.listening{border-color:#00d4ff;color:#00d4ff}

/* ===== Controller Settings ===== */
.mapping-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:8px}
.mapping-item{background:#111122;border:1px solid #2a2a4a;border-radius:6px;padding:10px;display:flex;flex-direction:column;align-items:center;gap:6px;cursor:pointer;transition:all .2s}
.mapping-item:hover{border-color:#00d4ff}
.mapping-item.waiting{border-color:#ffd700;animation:pulse 1s infinite}
.mapping-item .map-label{font-size:12px;color:#888}
.mapping-item .map-value{font-family:'Orbitron',sans-serif;font-size:14px;color:#00d4ff}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
#raw-monitor{background:#0a0a14;border:1px solid #2a2a4a;border-radius:6px;padding:12px;font-family:'Rajdhani',monospace;font-size:12px;color:#888;max-height:200px;overflow-y:auto;white-space:pre-wrap}

/* ===== Responsive ===== */
@media(max-width:900px){
  #sidebar{width:100%;flex-direction:row;overflow-x:auto;overflow-y:hidden;padding:0;border-right:none;border-bottom:1px solid #2a2a4a}
  .mode-btn{flex-direction:column;padding:8px 14px;border-left:none;border-bottom:3px solid transparent;min-width:max-content}
  .mode-btn.active{border-left-color:transparent;border-bottom-color:#00d4ff}
  #app{flex-direction:column}
}
</style>
</head>
<body>

<!-- ===== Header ===== -->
<div id="header">
  <h1>IIDX TRAINING LAB</h1>
  <div id="controller-status">
    <span class="dot"></span>
    <span id="controller-name">No Controller</span>
  </div>
</div>

<!-- ===== App ===== -->
<div id="app">

  <!-- Sidebar -->
  <div id="sidebar">
    <button class="mode-btn active" data-mode="pattern" onclick="switchMode('pattern')">
      <span class="icon">&#9835;</span>
      <span class="label"><span>配置パターン練習</span><span>Pattern Practice</span></span>
    </button>
    <button class="mode-btn" data-mode="scratch" onclick="switchMode('scratch')">
      <span class="icon">&#9842;</span>
      <span class="label"><span>皿絡み練習</span><span>Scratch Practice</span></span>
    </button>
    <button class="mode-btn" data-mode="recognition" onclick="switchMode('recognition')">
      <span class="icon">&#9881;</span>
      <span class="label"><span>認識力トレーニング</span><span>Recognition</span></span>
    </button>
    <button class="mode-btn" data-mode="speed" onclick="switchMode('speed')">
      <span class="icon">&#9889;</span>
      <span class="label"><span>打鍵速度・精度測定</span><span>Tap Speed</span></span>
    </button>
    <button class="mode-btn" data-mode="settings" onclick="switchMode('settings')">
      <span class="icon">&#9881;</span>
      <span class="label"><span>コントローラー設定</span><span>Controller Settings</span></span>
    </button>
  </div>

  <!-- Content -->
  <div id="content">

    <!-- Controller Visualizer -->
    <div id="visualizer">
      <div id="turntable"><div class="marker"></div></div>
      <div id="keys-viz">
        <div class="key-viz white" data-key="0">1</div>
        <div class="key-viz blue" data-key="1">2</div>
        <div class="key-viz white" data-key="2">3</div>
        <div class="key-viz blue" data-key="3">4</div>
        <div class="key-viz white" data-key="4">5</div>
        <div class="key-viz blue" data-key="5">6</div>
        <div class="key-viz white" data-key="6">7</div>
      </div>
      <div id="scratch-indicator">--</div>
      <div id="debug-input" style="font-family:monospace;font-size:11px;color:#666;margin-left:auto;white-space:pre;max-width:300px;overflow:hidden"></div>
    </div>

    <!-- ===== Mode 1: Pattern Practice ===== -->
    <div class="mode-panel active" id="panel-pattern">
      <div class="panel-title">配置パターン練習</div>
      <div class="panel-controls">
        <div class="control-group">
          <label>パターン</label>
          <select id="pat-type">
            <option value="stairs">階段</option>
            <option value="reverse-stairs">逆階段</option>
            <option value="trill">トリル</option>
            <option value="chords">同時押し</option>
            <option value="denim">デニム</option>
            <option value="chord-stairs">同時押し階段</option>
            <option value="random">ランダム</option>
            <option value="charge">チャージノート</option>
          </select>
        </div>
        <div class="control-group">
          <label>BPM: <span id="pat-bpm-val">150</span></label>
          <input type="range" id="pat-bpm" min="60" max="300" step="10" value="150" oninput="document.getElementById('pat-bpm-val').textContent=this.value">
        </div>
        <div class="control-group">
          <label>HS: <span id="pat-hs-val">3.0</span></label>
          <input type="range" id="pat-hs" min="1" max="8" step="0.5" value="3" oninput="document.getElementById('pat-hs-val').textContent=parseFloat(this.value).toFixed(1)">
        </div>
        <button class="btn btn-primary" id="pat-start-btn" onclick="togglePattern()">START</button>
      </div>
      <div style="position:relative">
        <div id="play-area">
          <div id="lanes-container"></div>
          <div id="judgment-line"></div>
          <div id="judgment-display"></div>
          <div id="combo-display"></div>
          <div id="play-info"></div>
        </div>
        <div id="result-overlay">
          <h2>RESULT</h2>
          <div id="result-stats"></div>
          <button class="btn btn-primary" onclick="closeResult()">CLOSE</button>
        </div>
      </div>
    </div>

    <!-- ===== Mode 2: Scratch Practice ===== -->
    <div class="mode-panel" id="panel-scratch">
      <div class="panel-title">皿絡み練習</div>
      <div class="panel-controls">
        <div class="control-group">
          <label>パターン</label>
          <select id="scratch-type">
            <option value="scratch-only">皿単体</option>
            <option value="scratch-keys">皿+鍵盤</option>
            <option value="scratch-chords">皿+同時押し</option>
            <option value="rapid-scratch">連皿</option>
            <option value="bss">BSS風</option>
          </select>
        </div>
        <div class="control-group">
          <label>BPM: <span id="scratch-bpm-val">140</span></label>
          <input type="range" id="scratch-bpm" min="60" max="300" step="10" value="140" oninput="document.getElementById('scratch-bpm-val').textContent=this.value">
        </div>
        <div class="control-group">
          <label>HS: <span id="scratch-hs-val">3.0</span></label>
          <input type="range" id="scratch-hs" min="1" max="8" step="0.5" value="3" oninput="document.getElementById('scratch-hs-val').textContent=parseFloat(this.value).toFixed(1)">
        </div>
        <button class="btn btn-primary" id="scratch-start-btn" onclick="toggleScratch()">START</button>
      </div>
    </div>

    <!-- ===== Mode 3: Recognition Training ===== -->
    <div class="mode-panel" id="panel-recognition">
      <div class="panel-title">認識力トレーニング</div>
      <div class="panel-controls">
        <div class="control-group">
          <label>難易度</label>
          <select id="recog-level">
            <option value="1">Lv.1 - 単鍵</option>
            <option value="2">Lv.2 - 2つ同時</option>
            <option value="3">Lv.3 - 3つ同時</option>
            <option value="4">Lv.4 - 皿含む</option>
            <option value="5">Lv.5 - 高速</option>
          </select>
        </div>
        <div class="control-group">
          <label>問題数: <span id="recog-count-val">20</span></label>
          <input type="range" id="recog-count" min="5" max="100" step="5" value="20" oninput="document.getElementById('recog-count-val').textContent=this.value">
        </div>
        <button class="btn btn-primary" id="recog-start-btn" onclick="toggleRecognition()">START</button>
      </div>
      <div id="recog-timer-bar"><div id="recog-timer-fill" style="width:0%"></div></div>
      <div id="recog-status"></div>
      <div id="recognition-display"></div>
      <div class="stats-row" id="recog-stats"></div>
    </div>

    <!-- ===== Mode 4: Tap Speed ===== -->
    <div class="mode-panel" id="panel-speed">
      <div class="panel-title">打鍵速度・精度測定</div>
      <div class="panel-controls">
        <div class="control-group">
          <label>対象キー</label>
          <select id="speed-target">
            <option value="all">すべてのキー</option>
            <option value="scratch">皿のみ</option>
            <option value="0">1鍵</option>
            <option value="1">2鍵</option>
            <option value="2">3鍵</option>
            <option value="3">4鍵</option>
            <option value="4">5鍵</option>
            <option value="5">6鍵</option>
            <option value="6">7鍵</option>
          </select>
        </div>
        <button class="btn btn-primary" id="speed-start-btn" onclick="toggleSpeed()">START</button>
        <button class="btn btn-secondary" onclick="resetSpeed()">RESET</button>
      </div>
      <div id="tap-target-area">対象キーを押してください</div>
      <div class="stats-row" id="speed-stats">
        <div class="stat-box"><div class="val" id="speed-tap">0</div><div class="lbl">TAP COUNT</div></div>
        <div class="stat-box"><div class="val" id="speed-bpm">--</div><div class="lbl">BPM (16分)</div></div>
        <div class="stat-box"><div class="val" id="speed-avg">--</div><div class="lbl">平均間隔 (ms)</div></div>
        <div class="stat-box"><div class="val" id="speed-std">--</div><div class="lbl">標準偏差 (ms)</div></div>
        <div class="stat-box"><div class="val" id="speed-stability">--</div><div class="lbl">安定度 (%)</div></div>
      </div>
    </div>

    <!-- ===== Mode 5: Controller Settings ===== -->
    <div class="mode-panel" id="panel-settings">
      <div class="panel-title">コントローラー設定</div>
      <div class="panel-controls">
        <button class="btn btn-secondary" onclick="resetMapping()">デフォルトに戻す</button>
      </div>
      <h3 style="font-size:14px;color:#888;margin-top:4px">ボタンマッピング（クリックして入力待ち → コントローラーのボタンを押して割り当て）</h3>
      <div class="mapping-grid" id="mapping-grid"></div>
      <h3 style="font-size:14px;color:#888;margin-top:8px">RAW入力モニター</h3>
      <div id="raw-monitor">接続待ち...</div>
    </div>

  </div>
</div>

<script>
/* ===================================================================
   IIDX TRAINING LAB - Main Script
   =================================================================== */

// ===== Global State =====
const state = {
  currentMode: 'pattern',
  // Controller
  gamepadIndex: -1,
  gamepadConnected: false,
  // Input
  keys: [false,false,false,false,false,false,false], // 7 keys
  prevKeys: [false,false,false,false,false,false,false],
  scratchVal: 0,
  prevScratchVal: 0,
  scratchActive: false,
  scratchDir: 0, // -1 down, 0 none, 1 up
  scratchActiveTimer: 0,
  turntableAngle: 0,
  lastScratchJudgeTime: 0,
  // Mapping
  mapping: {
    keys: [0,1,2,3,4,5,6], // gamepad button indices
    scratchMode: 'axis', // 'axis' or 'buttons'
    scratchAxis: 0,
    scratchThreshold: 0.002,
    scratchBtnUp: -1, // button index for scratch up (CW)
    scratchBtnDown: -1  // button index for scratch down (CCW)
  },
  waitingMapping: null,
  // Keyboard state
  kbKeys: [false,false,false,false,false,false,false],
  kbScratchUp: false,
  kbScratchDown: false,
  // Pattern mode
  patternRunning: false,
  patternNotes: [],
  patternStartTime: 0,
  patternLastGen: 0,
  patternStep: 0,
  patternCombo: 0,
  patternMaxCombo: 0,
  patternJudgments: {pgreat:0,great:0,good:0,bad:0,poor:0},
  patternTotalNotes: 0,
  patternScore: 0,
  // Scratch mode
  scratchRunning: false,
  scratchNotes: [],
  scratchStartTime: 0,
  scratchLastGen: 0,
  scratchStep: 0,
  scratchCombo: 0,
  scratchMaxCombo: 0,
  scratchJudgments: {pgreat:0,great:0,good:0,bad:0,poor:0},
  scratchTotalNotes: 0,
  scratchScore: 0,
  // Recognition mode
  recogRunning: false,
  recogPhase: 'idle', // idle, show, hide, input, feedback
  recogCurrent: [],
  recogQuestion: 0,
  recogCorrect: 0,
  recogWrong: 0,
  recogTimes: [],
  recogPhaseStart: 0,
  // Speed mode
  speedRunning: false,
  speedTaps: [],
  speedCount: 0
};

// ===== DOM References =====
const $ = id => document.getElementById(id);
const turntableEl = $('turntable');
const keyVizEls = document.querySelectorAll('.key-viz');
const scratchIndicator = $('scratch-indicator');
const lanesContainer = $('lanes-container');
const judgmentDisplay = $('judgment-display');
const comboDisplay = $('combo-display');
const playInfo = $('play-info');
const playArea = $('play-area');
const resultOverlay = $('result-overlay');
const resultStats = $('result-stats');

// ===== Keyboard Mapping =====
const KB_MAP = {
  'KeyS': 0, 'KeyD': 1, 'KeyF': 2, 'Space': 3, 'KeyJ': 4, 'KeyK': 5, 'KeyL': 6
};

// ===== Init Lanes =====
function initLanes() {
  lanesContainer.innerHTML = '';
  // Scratch lane
  const sLane = document.createElement('div');
  sLane.className = 'lane scratch-lane';
  sLane.innerHTML = '<div class="lane-bg"></div><div class="lane-flash"></div>';
  sLane.dataset.lane = 'scratch';
  lanesContainer.appendChild(sLane);
  // 7 key lanes
  for (let i = 0; i < 7; i++) {
    const lane = document.createElement('div');
    const isWhite = i % 2 === 0; // 0,2,4,6 = white (1,3,5,7鍵)
    lane.className = `lane key-lane ${isWhite ? 'white-lane' : 'blue-lane'}`;
    lane.innerHTML = '<div class="lane-bg"></div><div class="lane-flash"></div>';
    lane.dataset.lane = i;
    lanesContainer.appendChild(lane);
  }
}
initLanes();

// ===== Input System =====
// Keyboard
document.addEventListener('keydown', e => {
  if (e.repeat) return;
  if (e.code in KB_MAP) {
    e.preventDefault();
    state.kbKeys[KB_MAP[e.code]] = true;
    handleKeyPress(KB_MAP[e.code]);
  }
  if (e.key === 'Shift') { e.preventDefault(); state.kbScratchUp = true; handleScratchInput(1); }
  if (e.key === 'Control') { e.preventDefault(); state.kbScratchDown = true; handleScratchInput(-1); }
});
document.addEventListener('keyup', e => {
  if (e.code in KB_MAP) { e.preventDefault(); state.kbKeys[KB_MAP[e.code]] = false; }
  if (e.key === 'Shift') { e.preventDefault(); state.kbScratchUp = false; }
  if (e.key === 'Control') { e.preventDefault(); state.kbScratchDown = false; }
});

// Gamepad connect/disconnect
window.addEventListener('gamepadconnected', e => {
  state.gamepadIndex = e.gamepad.index;
  state.gamepadConnected = true;
  $('controller-status').classList.add('connected');
  $('controller-name').textContent = e.gamepad.id.substring(0, 30);
});
window.addEventListener('gamepaddisconnected', () => {
  state.gamepadConnected = false;
  state.gamepadIndex = -1;
  $('controller-status').classList.remove('connected');
  $('controller-name').textContent = 'No Controller';
});

// ===== Gamepad Polling =====
function pollGamepad() {
  if (!state.gamepadConnected) return;
  const gp = navigator.getGamepads()[state.gamepadIndex];
  if (!gp) return;
  // Keys
  for (let i = 0; i < 7; i++) {
    const btnIdx = state.mapping.keys[i];
    const pressed = btnIdx < gp.buttons.length && gp.buttons[btnIdx].pressed;
    state.prevKeys[i] = state.keys[i];
    state.keys[i] = pressed;
    if (pressed && !state.prevKeys[i]) handleKeyPress(i);
  }
  // Scratch detection - supports both axis and button modes
  let scratchDetected = false;
  let scratchDirection = 0;

  // Method 1: Axis-based detection (low threshold for per-frame delta)
  const threshold = state.mapping.scratchThreshold;
  for (let a = 0; a < gp.axes.length; a++) {
    const prev = (state._prevAxes && state._prevAxes[a] !== undefined) ? state._prevAxes[a] : gp.axes[a];
    const cur = gp.axes[a];
    const delta = cur - prev;
    // Handle wrap-around
    let correctedDelta = delta;
    if (Math.abs(delta) > 1) correctedDelta = delta > 0 ? delta - 2 : delta + 2;
    if (Math.abs(correctedDelta) > threshold) {
      scratchDetected = true;
      scratchDirection = correctedDelta > 0 ? 1 : -1;
    }
  }
  // Save all axes for next frame comparison
  state._prevAxes = Array.from(gp.axes);

  // Method 2: Button-based detection (for controllers that map turntable to buttons)
  if (!scratchDetected) {
    const mappedBtns = new Set(state.mapping.keys);
    // Check configured scratch buttons
    if (state.mapping.scratchBtnUp >= 0 && state.mapping.scratchBtnUp < gp.buttons.length && gp.buttons[state.mapping.scratchBtnUp].pressed) {
      scratchDetected = true;
      scratchDirection = 1;
    }
    if (state.mapping.scratchBtnDown >= 0 && state.mapping.scratchBtnDown < gp.buttons.length && gp.buttons[state.mapping.scratchBtnDown].pressed) {
      scratchDetected = true;
      scratchDirection = -1;
    }
    // Auto-detect: any unmapped button press could be scratch
    if (!scratchDetected && state.mapping.scratchBtnUp < 0) {
      for (let b = 0; b < gp.buttons.length; b++) {
        if (mappedBtns.has(b)) continue;
        if (gp.buttons[b].pressed) {
          scratchDetected = true;
          scratchDirection = 1;
          break;
        }
      }
    }
  }

  if (scratchDetected) {
    state.scratchActive = true;
    state.scratchDir = scratchDirection;
    handleScratchInput(scratchDirection);
    state.scratchActiveTimer = 6;
  } else if (state.scratchActiveTimer > 0) {
    state.scratchActiveTimer--;
  } else {
    state.scratchActive = false;
    state.scratchDir = 0;
  }

  // Debug display: show active buttons & axes
  const dbg = $('debug-input');
  if (dbg) {
    let parts = [];
    for (let b = 0; b < gp.buttons.length; b++) {
      if (gp.buttons[b].pressed || gp.buttons[b].value > 0.1) parts.push(`B${b}:${gp.buttons[b].value.toFixed(1)}`);
    }
    for (let a = 0; a < gp.axes.length; a++) {
      if (Math.abs(gp.axes[a]) > 0.01) parts.push(`A${a}:${gp.axes[a].toFixed(3)}`);
    }
    dbg.textContent = parts.length > 0 ? parts.join(' ') : 'no input';
  }
  // Mapping waiting
  if (state.waitingMapping !== null) {
    for (let b = 0; b < gp.buttons.length; b++) {
      if (gp.buttons[b].pressed) {
        assignMapping(state.waitingMapping, b);
        break;
      }
    }
  }
  // RAW monitor (always update when settings panel visible)
  if ($('panel-settings').classList.contains('active')) updateRawMonitor(gp);
}

// ===== Handle Key Press =====
function handleKeyPress(keyIdx) {
  if (state.patternRunning) judgeKeyHit(keyIdx, state.patternNotes, 'pattern');
  if (state.scratchRunning) judgeKeyHit(keyIdx, state.scratchNotes, 'scratch');
  if (state.recogRunning) handleRecogInput(keyIdx, 'key');
  if (state.speedRunning) handleSpeedTap(keyIdx, 'key');
}

function handleScratchInput(dir) {
  const now = performance.now();
  // Cooldown: prevent rapid-fire judgment (one hit per ~60ms)
  if (now - state.lastScratchJudgeTime < 60) return;
  state.lastScratchJudgeTime = now;
  if (state.patternRunning) judgeScratchHit(state.patternNotes, 'pattern');
  if (state.scratchRunning) judgeScratchHit(state.scratchNotes, 'scratch');
  if (state.recogRunning) handleRecogInput(-1, 'scratch');
  if (state.speedRunning) handleSpeedTap(-1, 'scratch');
}

// ===== Visualizer Update =====
function updateVisualizer() {
  // Merge keyboard + gamepad states
  for (let i = 0; i < 7; i++) {
    const pressed = state.keys[i] || state.kbKeys[i];
    keyVizEls[i].classList.toggle('pressed', pressed);
  }
  // Turntable
  const scratchAny = state.scratchActive || state.kbScratchUp || state.kbScratchDown;
  let dir = state.scratchDir;
  if (state.kbScratchUp) dir = 1;
  if (state.kbScratchDown) dir = -1;
  if (scratchAny) {
    state.turntableAngle += dir * 15;
    turntableEl.style.transform = `rotate(${state.turntableAngle}deg)`;
    scratchIndicator.textContent = dir > 0 ? '↑' : '↓';
    scratchIndicator.style.color = '#cc2222';
  } else {
    scratchIndicator.textContent = '--';
    scratchIndicator.style.color = '#888';
  }
}

// ===== Mode Switching =====
function switchMode(mode) {
  state.currentMode = mode;
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
  document.querySelectorAll('.mode-panel').forEach(p => p.classList.remove('active'));
  const panel = $(`panel-${mode}`);
  if (panel) panel.classList.add('active');
}

// ===================================================================
// MODE 1: Pattern Practice
// ===================================================================

function getPatternConfig() {
  return {
    type: $('pat-type').value,
    bpm: parseInt($('pat-bpm').value),
    hs: parseFloat($('pat-hs').value)
  };
}

function togglePattern() {
  if (state.patternRunning) {
    stopPattern();
  } else {
    startPattern();
  }
}

function startPattern() {
  const cfg = getPatternConfig();
  state.patternRunning = true;
  state.patternNotes = [];
  state.patternStartTime = performance.now();
  state.patternLastGen = 0;
  state.patternStep = 0;
  state.patternCombo = 0;
  state.patternMaxCombo = 0;
  state.patternJudgments = {pgreat:0,great:0,good:0,bad:0,poor:0};
  state.patternTotalNotes = 0;
  state.patternScore = 0;
  $('pat-start-btn').textContent = 'STOP';
  $('pat-start-btn').classList.replace('btn-primary','btn-danger');
  resultOverlay.classList.remove('active');
  comboDisplay.style.opacity = '0';
  judgmentDisplay.style.opacity = '0';
  clearNotes();
}

function stopPattern() {
  state.patternRunning = false;
  $('pat-start-btn').textContent = 'START';
  $('pat-start-btn').classList.replace('btn-danger','btn-primary');
  showResult('pattern');
}

function generatePatternNote(cfg, now) {
  const interval = 60000 / cfg.bpm / 4; // 16th note
  const elapsed = now - state.patternStartTime;
  if (elapsed < 1000) return; // start after 1 second
  if (now - state.patternLastGen < interval) return;
  state.patternLastGen = now;

  const fallTime = 2000 / (cfg.bpm / 150 * cfg.hs);
  const hitTime = now + fallTime;
  const lanes = getPatternLanes(cfg.type);

  lanes.forEach(lane => {
    const note = { lane, hitTime, el: null, judged: false };
    createNoteElement(note, fallTime);
    state.patternNotes.push(note);
    state.patternTotalNotes++;
  });
}

function getPatternLanes(type) {
  const s = state.patternStep;
  let lanes;
  switch (type) {
    case 'stairs': {
      // 0,1,2,3,4,5,6,5,4,3,2,1,0,1,...
      const seq = [0,1,2,3,4,5,6,5,4,3,2,1];
      lanes = [seq[s % seq.length]];
      break;
    }
    case 'reverse-stairs': {
      const seq = [6,5,4,3,2,1,0,1,2,3,4,5];
      lanes = [seq[s % seq.length]];
      break;
    }
    case 'trill': {
      const pairs = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]];
      const pairIdx = Math.floor(s / 16) % pairs.length;
      const pair = pairs[pairIdx];
      lanes = [pair[s % 2]];
      break;
    }
    case 'chords': {
      const patterns = [[0,3],[1,4],[2,5],[3,6],[0,2,4],[1,3,5],[2,4,6],[0,3,5,6]];
      lanes = patterns[s % patterns.length];
      break;
    }
    case 'denim': {
      const seq = [0,2,4,6,5,3,1];
      lanes = [seq[s % seq.length]];
      break;
    }
    case 'chord-stairs': {
      const pairs = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[4,5],[3,4],[2,3],[1,2]];
      lanes = pairs[s % pairs.length];
      break;
    }
    case 'random': {
      const count = 1 + Math.floor(Math.random() * 3);
      const available = [0,1,2,3,4,5,6];
      lanes = [];
      for (let i = 0; i < count; i++) {
        const idx = Math.floor(Math.random() * available.length);
        lanes.push(available.splice(idx, 1)[0]);
      }
      break;
    }
    case 'charge': {
      const seq = [0,1,2,3,4,5,6,5,4,3,2,1];
      lanes = [seq[s % seq.length]];
      break;
    }
    default:
      lanes = [s % 7];
  }
  state.patternStep++;
  return lanes;
}

// ===================================================================
// MODE 2: Scratch Practice
// ===================================================================

function getScratchConfig() {
  return {
    type: $('scratch-type').value,
    bpm: parseInt($('scratch-bpm').value),
    hs: parseFloat($('scratch-hs').value)
  };
}

function toggleScratch() {
  if (state.scratchRunning) stopScratch();
  else startScratch();
}

function startScratch() {
  const cfg = getScratchConfig();
  state.scratchRunning = true;
  state.scratchNotes = [];
  state.scratchStartTime = performance.now();
  state.scratchLastGen = 0;
  state.scratchStep = 0;
  state.scratchCombo = 0;
  state.scratchMaxCombo = 0;
  state.scratchJudgments = {pgreat:0,great:0,good:0,bad:0,poor:0};
  state.scratchTotalNotes = 0;
  state.scratchScore = 0;
  $('scratch-start-btn').textContent = 'STOP';
  $('scratch-start-btn').classList.replace('btn-primary','btn-danger');
  // Use pattern play area (move it if needed)
  switchMode('pattern');
  document.querySelector('[data-mode="scratch"]').classList.add('active');
  document.querySelector('[data-mode="pattern"]').classList.remove('active');
  $('panel-pattern').classList.add('active');
  resultOverlay.classList.remove('active');
  comboDisplay.style.opacity = '0';
  judgmentDisplay.style.opacity = '0';
  clearNotes();
}

function stopScratch() {
  state.scratchRunning = false;
  $('scratch-start-btn').textContent = 'START';
  $('scratch-start-btn').classList.replace('btn-danger','btn-primary');
  showResult('scratch');
}

function generateScratchNote(cfg, now) {
  const interval = 60000 / cfg.bpm / 4;
  const elapsed = now - state.scratchStartTime;
  if (elapsed < 1000) return;
  if (now - state.scratchLastGen < interval) return;
  state.scratchLastGen = now;
  const fallTime = 2000 / (cfg.bpm / 150 * cfg.hs);
  const hitTime = now + fallTime;
  const lanes = getScratchLanes(cfg.type);
  lanes.forEach(lane => {
    const note = { lane, hitTime, el: null, judged: false };
    createNoteElement(note, fallTime);
    state.scratchNotes.push(note);
    state.scratchTotalNotes++;
  });
}

function getScratchLanes(type) {
  const s = state.scratchStep;
  let lanes;
  switch (type) {
    case 'scratch-only':
      lanes = ['scratch'];
      break;
    case 'scratch-keys': {
      if (s % 2 === 0) lanes = ['scratch'];
      else lanes = [Math.floor(Math.random() * 3)]; // 1-3 keys
      break;
    }
    case 'scratch-chords': {
      if (s % 2 === 0) lanes = ['scratch'];
      else {
        const count = 2 + Math.floor(Math.random() * 3);
        const avail = [0,1,2,3,4,5,6];
        lanes = [];
        for (let i = 0; i < count; i++) {
          const idx = Math.floor(Math.random() * avail.length);
          lanes.push(avail.splice(idx, 1)[0]);
        }
      }
      break;
    }
    case 'rapid-scratch': {
      if (s % 4 === 3) lanes = [Math.floor(Math.random() * 7)];
      else lanes = ['scratch'];
      break;
    }
    case 'bss': {
      // BSS-style: scratch for several beats then keys
      if (s % 8 < 5) lanes = ['scratch'];
      else lanes = [Math.floor(Math.random() * 3)];
      break;
    }
    default:
      lanes = ['scratch'];
  }
  state.scratchStep++;
  return lanes;
}

// ===================================================================
// Shared Note Rendering & Judgment
// ===================================================================

function createNoteElement(note, fallTime) {
  const el = document.createElement('div');
  el.className = 'note';
  if (note.lane === 'scratch') {
    el.classList.add('scratch-note');
    const laneEl = lanesContainer.querySelector('[data-lane="scratch"]');
    if (laneEl) laneEl.appendChild(el);
  } else {
    const isWhite = note.lane % 2 === 0;
    el.classList.add(isWhite ? 'white-note' : 'blue-note');
    const laneEl = lanesContainer.querySelector(`[data-lane="${note.lane}"]`);
    if (laneEl) laneEl.appendChild(el);
  }
  note.el = el;
}

function updateNotes(notes, now, mode) {
  const cfg = mode === 'scratch' ? getScratchConfig() : getPatternConfig();
  const fallTime = 2000 / (cfg.bpm / 150 * cfg.hs);
  const playH = 500;
  const judgY = playH - 60;

  for (let i = notes.length - 1; i >= 0; i--) {
    const note = notes[i];
    if (note.judged) continue;
    const timeLeft = note.hitTime - now;
    const progress = 1 - (timeLeft / fallTime);
    const y = progress * judgY;
    if (note.el) note.el.style.top = y + 'px';

    // POOR (missed)
    if (timeLeft < -150) {
      note.judged = true;
      if (note.el) note.el.remove();
      registerJudgment('poor', mode);
      notes.splice(i, 1);
    }
  }
  // Update info display
  playInfo.textContent = `BPM ${cfg.bpm} | HS ${cfg.hs.toFixed(1)}`;
}

function judgeKeyHit(keyIdx, notes, mode) {
  const now = performance.now();
  let best = null, bestDiff = Infinity;
  for (const note of notes) {
    if (note.judged || note.lane !== keyIdx) continue;
    const diff = Math.abs(now - note.hitTime);
    if (diff < 150 && diff < bestDiff) { bestDiff = diff; best = note; }
  }
  if (!best) return;
  best.judged = true;
  if (best.el) best.el.remove();
  flashLane(keyIdx);
  if (bestDiff <= 20) registerJudgment('pgreat', mode);
  else if (bestDiff <= 50) registerJudgment('great', mode);
  else if (bestDiff <= 100) registerJudgment('good', mode);
  else registerJudgment('bad', mode);
}

function judgeScratchHit(notes, mode) {
  const now = performance.now();
  let best = null, bestDiff = Infinity;
  for (const note of notes) {
    if (note.judged || note.lane !== 'scratch') continue;
    const diff = Math.abs(now - note.hitTime);
    if (diff < 150 && diff < bestDiff) { bestDiff = diff; best = note; }
  }
  if (!best) return;
  best.judged = true;
  if (best.el) best.el.remove();
  flashLane('scratch');
  if (bestDiff <= 20) registerJudgment('pgreat', mode);
  else if (bestDiff <= 50) registerJudgment('great', mode);
  else if (bestDiff <= 100) registerJudgment('good', mode);
  else if (bestDiff <= 150) registerJudgment('bad', mode);
  else registerJudgment('poor', mode);
}

function registerJudgment(type, mode) {
  const j = mode === 'scratch' ? state.scratchJudgments : state.patternJudgments;
  j[type]++;
  const colors = {pgreat:'#ffd700',great:'#ffaa00',good:'#44cc44',bad:'#cc4444',poor:'#888'};
  const labels = {pgreat:'P-GREAT',great:'GREAT',good:'GOOD',bad:'BAD',poor:'POOR'};
  judgmentDisplay.textContent = labels[type];
  judgmentDisplay.style.color = colors[type];
  judgmentDisplay.style.opacity = '1';
  setTimeout(() => judgmentDisplay.style.opacity = '0', 300);

  if (type === 'bad' || type === 'poor') {
    if (mode === 'scratch') { state.scratchCombo = 0; }
    else { state.patternCombo = 0; }
    comboDisplay.style.opacity = '0';
  } else {
    if (mode === 'scratch') {
      state.scratchCombo++;
      if (state.scratchCombo > state.scratchMaxCombo) state.scratchMaxCombo = state.scratchCombo;
      comboDisplay.textContent = state.scratchCombo;
    } else {
      state.patternCombo++;
      if (state.patternCombo > state.patternMaxCombo) state.patternMaxCombo = state.patternCombo;
      comboDisplay.textContent = state.patternCombo;
    }
    comboDisplay.style.opacity = '1';
  }
  // Score
  const scoreMul = type === 'pgreat' ? 2 : type === 'great' ? 1 : 0;
  if (mode === 'scratch') state.scratchScore += scoreMul;
  else state.patternScore += scoreMul;
}

function flashLane(lane) {
  const sel = lane === 'scratch' ? '[data-lane="scratch"]' : `[data-lane="${lane}"]`;
  const el = lanesContainer.querySelector(sel);
  if (!el) return;
  const flash = el.querySelector('.lane-flash');
  if (!flash) return;
  flash.style.opacity = '1';
  setTimeout(() => flash.style.opacity = '0', 100);
}

function clearNotes() {
  lanesContainer.querySelectorAll('.note').forEach(n => n.remove());
}

function showResult(mode) {
  const j = mode === 'scratch' ? state.scratchJudgments : state.patternJudgments;
  const total = mode === 'scratch' ? state.scratchTotalNotes : state.patternTotalNotes;
  const maxCombo = mode === 'scratch' ? state.scratchMaxCombo : state.patternMaxCombo;
  const score = mode === 'scratch' ? state.scratchScore : state.patternScore;
  const accuracy = total > 0 ? ((j.pgreat * 2 + j.great) / (total * 2) * 100).toFixed(2) : '0.00';

  resultStats.innerHTML = `
    <div class="stat-box"><div class="val" style="color:#ffd700">${j.pgreat}</div><div class="lbl">P-GREAT</div></div>
    <div class="stat-box"><div class="val" style="color:#ffaa00">${j.great}</div><div class="lbl">GREAT</div></div>
    <div class="stat-box"><div class="val" style="color:#44cc44">${j.good}</div><div class="lbl">GOOD</div></div>
    <div class="stat-box"><div class="val" style="color:#cc4444">${j.bad}</div><div class="lbl">BAD</div></div>
    <div class="stat-box"><div class="val" style="color:#888">${j.poor}</div><div class="lbl">POOR</div></div>
    <div class="stat-box"><div class="val">${maxCombo}</div><div class="lbl">MAX COMBO</div></div>
    <div class="stat-box"><div class="val">${score}</div><div class="lbl">SCORE</div></div>
    <div class="stat-box"><div class="val">${accuracy}%</div><div class="lbl">ACCURACY</div></div>
  `;
  resultOverlay.classList.add('active');
}

function closeResult() {
  resultOverlay.classList.remove('active');
  clearNotes();
}

// ===================================================================
// MODE 3: Recognition Training
// ===================================================================

function toggleRecognition() {
  if (state.recogRunning) stopRecognition();
  else startRecognition();
}

function startRecognition() {
  state.recogRunning = true;
  state.recogQuestion = 0;
  state.recogCorrect = 0;
  state.recogWrong = 0;
  state.recogTimes = [];
  $('recog-start-btn').textContent = 'STOP';
  $('recog-start-btn').classList.replace('btn-primary','btn-danger');
  updateRecogStats();
  nextRecogQuestion();
}

function stopRecognition() {
  state.recogRunning = false;
  state.recogPhase = 'idle';
  $('recog-start-btn').textContent = 'START';
  $('recog-start-btn').classList.replace('btn-danger','btn-primary');
  $('recog-status').textContent = '';
  $('recog-timer-fill').style.width = '0%';
  renderRecogKeys([]);
}

function nextRecogQuestion() {
  const total = parseInt($('recog-count').value);
  if (state.recogQuestion >= total) {
    stopRecognition();
    return;
  }
  state.recogQuestion++;
  const level = parseInt($('recog-level').value);
  state.recogCurrent = generateRecogPattern(level);
  state.recogPhase = 'show';
  state.recogPhaseStart = performance.now();
  renderRecogKeys(state.recogCurrent, true);
  $('recog-status').textContent = `問題 ${state.recogQuestion} / ${total}`;

  const showTime = level === 5 ? 300 : 1500;
  $('recog-timer-fill').style.transition = `width ${showTime}ms linear`;
  $('recog-timer-fill').style.width = '100%';
  setTimeout(() => {
    $('recog-timer-fill').style.transition = 'none';
    $('recog-timer-fill').style.width = '0%';
  }, 10);

  setTimeout(() => {
    if (!state.recogRunning) return;
    state.recogPhase = 'input';
    state.recogPhaseStart = performance.now();
    renderRecogKeys(state.recogCurrent, false);
    $('recog-status').textContent = '入力してください！';
  }, showTime);
}

function generateRecogPattern(level) {
  const keys = [];
  let count;
  switch (level) {
    case 1: count = 1; break;
    case 2: count = 2; break;
    case 3: count = 3; break;
    case 4: count = 3 + Math.floor(Math.random() * 2); break; // 3-4 with scratch
    case 5: count = 3 + Math.floor(Math.random() * 2); break;
    default: count = 1;
  }
  const available = [0,1,2,3,4,5,6];
  for (let i = 0; i < count && available.length > 0; i++) {
    const idx = Math.floor(Math.random() * available.length);
    keys.push(available.splice(idx, 1)[0]);
  }
  if (level === 4 && Math.random() > 0.3) keys.push('scratch');
  return keys.sort((a,b) => {
    if (a === 'scratch') return -1;
    if (b === 'scratch') return 1;
    return a - b;
  });
}

function renderRecogKeys(pattern, showActive) {
  const container = $('recognition-display');
  container.innerHTML = '';
  // Scratch
  const sKey = document.createElement('div');
  sKey.className = 'recog-key';
  sKey.textContent = showActive === undefined ? 'S' : (showActive ? (pattern.includes('scratch') ? 'S' : '') : '?');
  if (showActive && pattern.includes('scratch')) sKey.classList.add('active');
  container.appendChild(sKey);
  // 7 keys
  for (let i = 0; i < 7; i++) {
    const k = document.createElement('div');
    k.className = 'recog-key';
    k.textContent = showActive === undefined ? (i+1) : (showActive ? (pattern.includes(i) ? (i+1) : '') : '?');
    if (showActive && pattern.includes(i)) k.classList.add('active');
    container.appendChild(k);
  }
}

let recogInputBuffer = new Set();
let recogInputTimeout = null;

function handleRecogInput(keyIdx, type) {
  if (!state.recogRunning || state.recogPhase !== 'input') return;
  if (type === 'scratch') recogInputBuffer.add('scratch');
  else recogInputBuffer.add(keyIdx);
  clearTimeout(recogInputTimeout);
  recogInputTimeout = setTimeout(() => checkRecogAnswer(), 200);
}

function checkRecogAnswer() {
  const input = Array.from(recogInputBuffer).sort((a,b) => {
    if (a === 'scratch') return -1;
    if (b === 'scratch') return 1;
    return a - b;
  });
  recogInputBuffer.clear();
  const expected = state.recogCurrent;
  const reactionTime = performance.now() - state.recogPhaseStart;
  const correct = JSON.stringify(input) === JSON.stringify(expected);

  if (correct) {
    state.recogCorrect++;
    state.recogTimes.push(reactionTime);
    showRecogFeedback(true);
  } else {
    state.recogWrong++;
    showRecogFeedback(false);
  }
  updateRecogStats();
}

function showRecogFeedback(correct) {
  state.recogPhase = 'feedback';
  const container = $('recognition-display');
  const keys = container.querySelectorAll('.recog-key');
  // Show correct pattern
  const pattern = state.recogCurrent;
  keys[0].textContent = pattern.includes('scratch') ? 'S' : '';
  keys[0].classList.toggle('correct', correct && pattern.includes('scratch'));
  keys[0].classList.toggle('wrong', !correct && pattern.includes('scratch'));
  for (let i = 0; i < 7; i++) {
    keys[i+1].textContent = pattern.includes(i) ? (i+1) : '';
    keys[i+1].classList.toggle('correct', correct && pattern.includes(i));
    keys[i+1].classList.toggle('wrong', !correct && pattern.includes(i));
  }
  $('recog-status').textContent = correct ? '正解！' : '不正解...';
  $('recog-status').style.color = correct ? '#22cc44' : '#cc2222';
  setTimeout(() => {
    $('recog-status').style.color = '#ffd700';
    if (state.recogRunning) nextRecogQuestion();
  }, 800);
}

function updateRecogStats() {
  const total = state.recogCorrect + state.recogWrong;
  const avgTime = state.recogTimes.length > 0 ? (state.recogTimes.reduce((a,b)=>a+b,0)/state.recogTimes.length).toFixed(0) : '--';
  const accuracy = total > 0 ? (state.recogCorrect / total * 100).toFixed(1) : '--';
  $('recog-stats').innerHTML = `
    <div class="stat-box"><div class="val" style="color:#22cc44">${state.recogCorrect}</div><div class="lbl">正解</div></div>
    <div class="stat-box"><div class="val" style="color:#cc2222">${state.recogWrong}</div><div class="lbl">不正解</div></div>
    <div class="stat-box"><div class="val">${avgTime}</div><div class="lbl">平均反応時間 (ms)</div></div>
    <div class="stat-box"><div class="val">${accuracy}</div><div class="lbl">正解率 (%)</div></div>
  `;
}

// ===================================================================
// MODE 4: Tap Speed / Accuracy
// ===================================================================

function toggleSpeed() {
  if (state.speedRunning) {
    state.speedRunning = false;
    $('speed-start-btn').textContent = 'START';
    $('speed-start-btn').classList.replace('btn-danger','btn-primary');
    $('tap-target-area').classList.remove('listening');
    $('tap-target-area').textContent = '対象キーを押してください';
  } else {
    state.speedRunning = true;
    state.speedTaps = [];
    state.speedCount = 0;
    $('speed-start-btn').textContent = 'STOP';
    $('speed-start-btn').classList.replace('btn-primary','btn-danger');
    $('tap-target-area').classList.add('listening');
    $('tap-target-area').textContent = '入力待ち...';
    updateSpeedStats();
  }
}

function resetSpeed() {
  state.speedTaps = [];
  state.speedCount = 0;
  updateSpeedStats();
}

function handleSpeedTap(keyIdx, type) {
  if (!state.speedRunning) return;
  const target = $('speed-target').value;
  // Filter by target
  if (target === 'scratch' && type !== 'scratch') return;
  if (target !== 'all' && target !== 'scratch' && parseInt(target) !== keyIdx) return;
  if (target === 'all') { /* accept all */ }

  const now = performance.now();
  state.speedCount++;
  state.speedTaps.push(now);
  if (state.speedTaps.length > 64) state.speedTaps.shift();
  $('tap-target-area').textContent = `TAP! (${state.speedCount})`;
  updateSpeedStats();
}

function updateSpeedStats() {
  $('speed-tap').textContent = state.speedCount;
  if (state.speedTaps.length < 2) {
    $('speed-bpm').textContent = '--';
    $('speed-avg').textContent = '--';
    $('speed-std').textContent = '--';
    $('speed-stability').textContent = '--';
    return;
  }
  // Use last 16 taps (or fewer)
  const taps = state.speedTaps.slice(-17); // need 17 taps for 16 intervals
  const intervals = [];
  for (let i = 1; i < taps.length; i++) intervals.push(taps[i] - taps[i-1]);
  const last16 = intervals.slice(-16);
  const avg = last16.reduce((a,b)=>a+b,0) / last16.length;
  const bpm16 = (60000 / avg / 4).toFixed(1);
  const variance = last16.reduce((a,b)=>a+(b-avg)**2,0) / last16.length;
  const stdDev = Math.sqrt(variance);
  const stability = Math.max(0, 100 - stdDev * 2).toFixed(1);

  $('speed-bpm').textContent = bpm16;
  $('speed-avg').textContent = avg.toFixed(1);
  $('speed-std').textContent = stdDev.toFixed(1);
  $('speed-stability').textContent = stability;
}

// ===================================================================
// MODE 5: Controller Settings
// ===================================================================

function initMappingGrid() {
  const grid = $('mapping-grid');
  grid.innerHTML = '';
  const labels = ['1鍵','2鍵','3鍵','4鍵','5鍵','6鍵','7鍵'];
  for (let i = 0; i < 7; i++) {
    const item = document.createElement('div');
    item.className = 'mapping-item';
    item.dataset.mapKey = i;
    item.innerHTML = `<div class="map-label">${labels[i]}</div><div class="map-value">btn ${state.mapping.keys[i]}</div>`;
    item.onclick = () => startWaitMapping(i, item);
    grid.appendChild(item);
  }
  // Scratch Up button
  const suItem = document.createElement('div');
  suItem.className = 'mapping-item';
  suItem.dataset.mapKey = 'scratchUp';
  const suVal = state.mapping.scratchBtnUp >= 0 ? `btn ${state.mapping.scratchBtnUp}` : '未設定 (自動)';
  suItem.innerHTML = `<div class="map-label">皿↑ (ボタン)</div><div class="map-value">${suVal}</div>`;
  suItem.onclick = () => startWaitMapping('scratchUp', suItem);
  grid.appendChild(suItem);
  // Scratch Down button
  const sdItem = document.createElement('div');
  sdItem.className = 'mapping-item';
  sdItem.dataset.mapKey = 'scratchDown';
  const sdVal = state.mapping.scratchBtnDown >= 0 ? `btn ${state.mapping.scratchBtnDown}` : '未設定 (自動)';
  sdItem.innerHTML = `<div class="map-label">皿↓ (ボタン)</div><div class="map-value">${sdVal}</div>`;
  sdItem.onclick = () => startWaitMapping('scratchDown', sdItem);
  grid.appendChild(sdItem);
  // Scratch axis
  const sItem = document.createElement('div');
  sItem.className = 'mapping-item';
  sItem.dataset.mapKey = 'scratch';
  sItem.innerHTML = `<div class="map-label">皿 (軸)</div><div class="map-value">axis ${state.mapping.scratchAxis}</div>`;
  grid.appendChild(sItem);
  // Threshold
  const tItem = document.createElement('div');
  tItem.className = 'mapping-item';
  tItem.dataset.mapKey = 'threshold';
  tItem.innerHTML = `<div class="map-label">皿閾値</div><div class="map-value">${state.mapping.scratchThreshold}</div>`;
  grid.appendChild(tItem);
}

function startWaitMapping(keyIdx, el) {
  document.querySelectorAll('.mapping-item').forEach(e => e.classList.remove('waiting'));
  el.classList.add('waiting');
  el.querySelector('.map-value').textContent = '入力待ち...';
  state.waitingMapping = keyIdx;
}

function assignMapping(keyIdx, btnIdx) {
  if (keyIdx === 'scratchUp') {
    state.mapping.scratchBtnUp = btnIdx;
  } else if (keyIdx === 'scratchDown') {
    state.mapping.scratchBtnDown = btnIdx;
  } else {
    state.mapping.keys[keyIdx] = btnIdx;
  }
  state.waitingMapping = null;
  initMappingGrid();
}

function resetMapping() {
  state.mapping = {
    keys: [0,1,2,3,4,5,6],
    scratchMode: 'axis',
    scratchAxis: 0,
    scratchThreshold: 0.002,
    scratchBtnUp: -1,
    scratchBtnDown: -1
  };
  initMappingGrid();
}

function updateRawMonitor(gp) {
  let text = `ID: ${gp.id}\nButtons: ${gp.buttons.length} | Axes: ${gp.axes.length}\n\n`;
  text += 'Buttons:\n';
  for (let i = 0; i < gp.buttons.length; i++) {
    const b = gp.buttons[i];
    text += `  [${i}] ${b.pressed ? '■' : '□'} val=${b.value.toFixed(2)}\n`;
  }
  text += '\nAxes:\n';
  for (let i = 0; i < gp.axes.length; i++) {
    text += `  [${i}] ${gp.axes[i].toFixed(4)}\n`;
  }
  $('raw-monitor').textContent = text;
}

initMappingGrid();

// ===================================================================
// Main Game Loop
// ===================================================================

function gameLoop(timestamp) {
  const now = performance.now();

  // Input
  pollGamepad();
  updateVisualizer();

  // Pattern mode
  if (state.patternRunning) {
    generatePatternNote(getPatternConfig(), now);
    updateNotes(state.patternNotes, now, 'pattern');
  }

  // Scratch mode
  if (state.scratchRunning) {
    generateScratchNote(getScratchConfig(), now);
    updateNotes(state.scratchNotes, now, 'scratch');
  }

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
